import sys
import subprocess
import json
from bottle import route, run, debug, template, request, BaseRequest
import urllib.request
import urllib.parse

BaseRequest.MEMFILE_MAX = 2048 * 8192 # (or whatever you want)

########################################################################################
## DATA
########################################################################################
NUM_LIMBS = 3

SEED_HALVES = None  ## two 64 bit numbers that make the random seed for the generation of the shared a

NUM_REGISTERED_CLIENTS = 0  # since this is a single-threaded server, we don't need a lock on this value

CLIENT_PKs = {}  ## Contains the individual public keys generated by each client
CLIENT_READY = {}  ## Contains the address of each client; indicates when each client is ready for the shared key to be generated

SHARED_PK = None

CLIENT_DATA = {}  ## Stores the client's ciphertexts

COMPUTATION_RESULT = []  ## Stores the result of the encrypted computation
RESULT_SHARES = {}  ## Maps client number to decryption share


########################################################################################
## DATA GEN
########################################################################################
def generateSeed():
    s = subprocess.check_output(["bin/demo/ipri-demo/server/generateSeed"]).decode('utf-8')
    s = s.split('\n')
    s = [s[0], s[1]]
    print("Generated seed: ", s)

    global SEED_HALVES
    SEED_HALVES = s

## Assumes that all client data is in place
def computeOnEncryptedData():
    global COMPUTATION_RESULT
    if len(COMPUTATION_RESULT) > 0:
        return

    global CLIENT_DATA
    global NUM_LIMBS
    arguments = []
    for client in CLIENT_DATA:
        for ct in CLIENT_DATA[client]:
            for limb in range(NUM_LIMBS):
                ct[0][limb] = ct[0][limb][:len(ct[0][limb])-1]
                ct[1][limb] = ct[1][limb][:len(ct[1][limb])-1]
            # print("Ct: ", ct)
            arguments.extend(ct[0])
            arguments.extend(ct[1])

    # print("Demo arguments: ", arguments)

    result = subprocess.check_output(["bin/demo/ipri-demo/server/runDemo"] + arguments).decode('utf-8')
    # print(result)
    result = result.split('\n')
    # print(result)
    assert(len(result) >= 3)
    result = result[:len(result)-1]
    # print(result)
    assert(len(result) % 2 == 0)
    assert(len(result) == 4*NUM_LIMBS)

    # for i in range(0, len(result), 2):
        # COMPUTATION_RESULT.append([result[i], result[i+1]])

    COMPUTATION_RESULT = [ [ [],[] ], [ [],[] ] ]  ## Two cts, two limbs each
    for i in range(NUM_LIMBS):
        COMPUTATION_RESULT[0][0].append(result[i])
        COMPUTATION_RESULT[0][1].append(result[i + NUM_LIMBS])
        COMPUTATION_RESULT[1][0].append(result[i + 2*NUM_LIMBS])
        COMPUTATION_RESULT[1][1].append(result[i + 3*NUM_LIMBS])


    # print("Finished computing on encrypted data: ", COMPUTATION_RESULT)

########################################################################################
## SERVICES
########################################################################################

# Called by each client to inform the server of its presence
# The server will not begin any of the next phases until all
# registered clients have given their data.
@route('/register')
def register():
    print("In register")
    global NUM_REGISTERED_CLIENTS
    NUM_REGISTERED_CLIENTS += 1
    print("Returning from register")
    global SEED_HALVES
    return json.dumps({'clientNum': str(NUM_REGISTERED_CLIENTS), 'seedFirstHalf': SEED_HALVES[0], 'seedSecondHalf': SEED_HALVES[1]})

@route('/postPK', method=['POST'])
def postPK():
    print("Posting pk")

    clientNum = request.params.get('clientNum', 0, type=str)
    pka = request.params.get('pka', 0, type=str)
    pkb = request.params.get('pkb', 0, type=str)
    # print("Received pk " + str([pka, pkb]) + " from client " + str(clientNum))

    pka = pka.split(';')
    pkb = pkb.split(';')
    for i in range(len(pka)):
        pka[i] = pka[i][:len(pka[i])-1]
        pkb[i] = pkb[i][:len(pkb[i])-1]

    global CLIENT_PKs
    for client in CLIENT_PKs:
        if (pka != CLIENT_PKs[client][0]):
            raise Exception("All client pka's need to be the same!")

    CLIENT_PKs[str(clientNum)] = [pka, pkb]
    # print("Loaded pk as " + str([pka, pkb]))

    global CLIENT_READY
    CLIENT_READY[str(clientNum)] = False

    global CLIENT_DATA
    CLIENT_DATA[str(clientNum)] = []

    global RESULT_SHARES
    RESULT_SHARES[str(clientNum)] = []

    print("Finishing post pk...")
    print(CLIENT_READY)

@route('/keyGen', method=['POST'])
def generateSharedKey():
    print("In gen shared key...")

    clientNum = request.params.get('clientNum', 0, type=str)
    clientAddress = request.params.get('address', 0, type=str)

    global CLIENT_READY
    if not CLIENT_READY[clientNum]:
        CLIENT_READY[clientNum] = clientAddress
    print(CLIENT_READY)

    ## Check if all clients are ready
    ready = True
    for client in CLIENT_READY:
        if not CLIENT_READY[client]:
            ready = False
            break

    if ready:
        ## Generate shared key and send it to each client
        ### Make pk args list
        global CLIENT_PKs
        global NUM_REGISTERED_CLIENTS
        pks = []
        for client in CLIENT_PKs:
            pks.extend(CLIENT_PKs[client][0])
            pks.extend(CLIENT_PKs[client][1])

        # print("PKS: ", pks)

        sharedPK = subprocess.check_output(["bin/demo/ipri-demo/server/generateSharedKey"] + pks).decode('utf-8')
        sharedPK = sharedPK.split('\n')
        global NUM_LIMBS
        assert(len(sharedPK) == (2*NUM_LIMBS) + 1)
        # print("Shared pk: ", sharedPK)
        global SHARED_PK

        shPKa = []
        shPKb = []
        for i in range(NUM_LIMBS):
            shPKa.append(sharedPK[i])
            shPKb.append(sharedPK[i+NUM_LIMBS])

        SHARED_PK = [shPKa, shPKb]
        # print("Generated Shared Key: ", SHARED_PK)

        postPKArgs = {'numClients': str(NUM_REGISTERED_CLIENTS),'mpPKa': ';'.join(shPKa), 'mpPKb': ';'.join(shPKb)}
        urlPostPK = urllib.parse.urlencode(postPKArgs).encode('ascii')
        for client in CLIENT_READY:
            urllib.request.urlopen(CLIENT_READY[client] + 'receivePublicKey', urlPostPK)


@route('/postCt', method=['POST'])
def receiveClientCiphertext():
    print("In receive client ct...")
    global COMPUTATION_RESULT
    if len(COMPUTATION_RESULT) > 0:
        return

    clientNum = request.params.get('clientNum', 0, type=str)
    numCts = request.params.get('numCts', 0, type=int)
    # print("Received ciphertext from client ", clientNum)

    global CLIENT_DATA
    for ctInd in range(0, numCts):
        ctaLabel = "cta" + str(ctInd)
        ctbLabel = "ctb" + str(ctInd)
        clCTa = request.params.get(ctaLabel, 0, type=str).split(';')
        # print("cta: ", clCTa)
        clCTb = request.params.get(ctbLabel, 0, type=str).split(';')
        # print("ctb: ", clCTa)
        CLIENT_DATA[clientNum].append([clCTa, clCTb])

    ready = True
    for client in CLIENT_DATA:
        if len(CLIENT_DATA[client]) == 0:
            ready = False
            print("Not ready: ", client)
            # print(CLIENT_DATA)
            break

    if ready:
        computeOnEncryptedData()

        ctInd = 0
        requestCtArgs = {}
        for ct in COMPUTATION_RESULT:
            ctaLabel = 'cta' + str(ctInd)
            ctbLabel = 'ctb' + str(ctInd)
            requestCtArgs[ctaLabel] = ';'.join(ct[0])
            requestCtArgs[ctbLabel] = ';'.join(ct[1])
            ctInd += 1
        requestCtArgs['numCts'] = str(ctInd)
        print("Sending " + requestCtArgs['numCts'] + " cts to client")
        urlArgs = urllib.parse.urlencode(requestCtArgs).encode('ascii')

        global CLIENT_READY
        for client in CLIENT_READY:
            address = CLIENT_READY[client]
            urllib.request.urlopen(address + 'postEncryptedResult', urlArgs)

@route('/decrypt', method=['POST'])
def combineShares():
    print("In combine shares")
    clientNum = request.params.get('clientNum', 0, type=int)
    numShares = request.params.get('numShares', 0, type=int)
    print("Received " + str(numShares) + " from client " + str(clientNum))

    global RESULT_SHARES
    if len(RESULT_SHARES[str(clientNum)]) == 0:
        for s in range(numShares):
            shareLabel = "share" + str(s);
            RESULT_SHARES[str(clientNum)].append(request.params.get(shareLabel, 0, type=str).split(';'))

    ready = True
    for cl in RESULT_SHARES:
        if len(RESULT_SHARES[cl]) == 0:
            ready = False
            break

    if ready:
        ## Combine shares
        combArgs = [str(numShares)]
        for shareNum in range(numShares):
            for cl in RESULT_SHARES:
                combArgs.extend(RESULT_SHARES[cl][shareNum])

        # print("comb args: ", combArgs)

        results = subprocess.check_output(["bin/demo/ipri-demo/server/combineShares"] + combArgs).decode('utf-8')
        # print("Results: ", results)
        results = results.split('\n')
        results = results[:len(results)-1]
        assert(len(results) == numShares)

        ## Send results to client
        resArgs = {'numResults': str(numShares)}
        for r in range(len(results)):
            resLabel = 'result' + str(r)
            resArgs[resLabel] = results[r]

        urlArgs = urllib.parse.urlencode(resArgs).encode('ascii')
        global CLIENT_READY
        for cl in CLIENT_READY:
            urllib.request.urlopen(CLIENT_READY[cl] + 'postResult', urlArgs)


def resetGlobals(clientNum):
    global CLIENT_DATA
    CLIENT_DATA[clientNum] = []

    global COMPUTATION_RESULT
    COMPUTATION_RESULT = []

    global RESULT_SHARES
    RESULT_SHARES[clientNum] = []

@route('/reset', method=['POST'])
def startNewComp():
    clientNum = request.params.get('clientNum', 0, type=str)
    print("Received reset request from client ", clientNum)
    resetGlobals(clientNum)

########################################################################################
## Launch code
########################################################################################

generateSeed()
# SERVER_ADDRESS = '192.168.1.100'
SERVER_ADDRESS = 'localhost'
run(host=SERVER_ADDRESS, port=8080, debug=True)
